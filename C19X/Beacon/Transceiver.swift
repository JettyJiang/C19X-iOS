//
//  Transceiver.swift
//  C19X
//
//  Created by Freddy Choi on 01/04/2020.
//  Copyright Â© 2020 C19X. All rights reserved.
//

import Foundation
import CoreBluetooth
import os

/**
 Beacon transmitter and receiver for broadcasting and detecting frequently changing beacon codes
 that can be later resolved for on-device matching based on the daily beacon code seeds.
 
 Each registered device has a single shared secret that is generated and obtained from the server
 on registration. This is a one-off operation. The shared secret is then stored at the server and also
 in secure storage on the device. A sequence of day codes is then generated from the shared secret
 by recursively applying SHA to the hashes, and running the sequence in reverse to provide a finite
 list of forward secure codes, where historic codes cannot predict future codes. One day code is used
 per day. The daily beacon code seed is generated by reversing the day code binary data, and applying
 SHA to generate a hash as the seed. This separates the seed from the day code, and it is this seed
 that is being published by the central server later when a user submits their infection status, i.e.
 the published seed data cannot be reconnected to the day codes.
 
 Beacon codes for a day are generated by recursively hashing the daily beacon code seed to produce
 a collection of hashes, and the actual code is a long value produced by taking the modulo of each hash.
 This scheme makes it possible for the beacon codes to be regenerated on-device for matching given
 the daily seed codes.
 
 When a user submits his/her infection status, only the public identifier and infection status is transmitted
 to the central server. Given all the day codes are generated from the shared secret, the central server is
 able to generate and publish the relevant daily beacon seed codes for any time period for download by
 all the devices, which in turn can use the seed codes to generate the beacon codes for on-device
 matching. Given the original shared secret is shared only once via HTTPS and then stored securely
 on the server side, and also on the device, this scheme offers a small attack surface for decoding all
 the beacon codes.
 */
protocol Transceiver {
    /**
     Start transmitter and receiver to follow Bluetooth state changes to start and stop advertising and scanning.
     */
    func start(_ source: String)
    
    /**
     Stop transmitter and receiver will disable advertising, scanning and terminate all connections.
     */
    func stop(_ source: String)
    
    func append(_ delegate: ReceiverDelegate)
}

/// Time delay between notifications for subscribers.
let transceiverNotificationDelay = DispatchTimeInterval.seconds(8)

class ConcreteTransceiver: NSObject, Transceiver, LocationManagerDelegate {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "Transceiver")
    private let dayCodes: DayCodes
    private let beaconCodes: BeaconCodes
    private let queue = DispatchQueue(label: "org.c19x.beacon.Transceiver")
    private let transmitter: Transmitter
    private let receiver: Receiver
    private var delegates: [ReceiverDelegate] = []
    private let locationManager: LocationManager

    init(_ sharedSecret: SharedSecret, codeUpdateAfter: TimeInterval) {
        dayCodes = ConcreteDayCodes(sharedSecret)
        beaconCodes = ConcreteBeaconCodes(dayCodes)
        receiver = ConcreteReceiver(queue: queue)
        transmitter = ConcreteTransmitter(queue: queue, beaconCodes: beaconCodes, updateCodeAfter: codeUpdateAfter, receiver: receiver)
        locationManager = ConcreteLocationManager()
        super.init()
        locationManager.append(self)
    }
    
    func start(_ source: String) {
        os_log("start (source=%s)", log: self.log, type: .debug, source)
        transmitter.start(source)
        receiver.start(source)
        // REMOVE FOR PRODUCTION
        if source == "BGAppRefreshTask" {
            delegates.forEach { $0.receiver(didDetect: BeaconCode(0), rssi: RSSI(-10010)) }
        } else {
            delegates.forEach { $0.receiver(didDetect: BeaconCode(0), rssi: RSSI(-10000)) }
        }
    }

    func stop(_ source: String) {
        os_log("stop (source=%s)", log: self.log, type: .debug, source)
        transmitter.stop(source)
        receiver.stop(source)
    }
    
    func append(_ delegate: ReceiverDelegate) {
        delegates.append(delegate)
        receiver.append(delegate)
        transmitter.append(delegate)
    }
    
    // MARK:- LocationManagerDelegate
    
    func locationManager(didDetect: LocationChange) {
        receiver.scan("locationManager")
        os_log("Beacon state report (subscribers) ========", log: self.log, type: .debug)
        transmitter.subscribers().forEach() { central in
            os_log("Beacon state (uuid=%s,state=.subscribing)", log: self.log, type: .debug, central.identifier.uuidString)
        }
    }
}

class CachedBeaconData {
    var code: BeaconCode? {
        didSet {
            lastUpdatedAt = Date()
            codeUpdatedAt = Date()
        }
    }
    var rssi: RSSI? {
       didSet {
           lastUpdatedAt = Date()
       }
    }
    var codeUpdatedAt: Date = Date.distantPast
    var lastUpdatedAt: Date = Date.distantPast
}

class CentralManager: NSObject {
    private let log: OSLog
    private let identifier: String
    private let centralManagerDelegate: CentralManagerDelegate
    private let dispatchQueue: DispatchQueue
    private let cbCentralManager: CBCentralManager
    var peripheralIdentifiers: [UUID] { get { centralManagerDelegate.peripheralIdentifiers }}
    open override var description: String { get {
        return "<CentralManager-" + addressString + ":identifer=" + identifier + ",state=" + cbCentralManager.state.description + ",peripherals=" + peripheralIdentifiers.description + ">"
    }}

    init(_ identifier: String, serviceUUIDs: [CBUUID], peripheralIdentifiers: [UUID]) {
        log = OSLog(subsystem: "Beacon", category: "CentralManager(" + identifier + ")")
        os_log("init (%s,%s)", log: log, type: .debug, identifier, peripheralIdentifiers.description)
        self.identifier = identifier
        self.centralManagerDelegate = CentralManagerDelegate(identifier, serviceUUIDs: serviceUUIDs, peripheralIdentifiers: peripheralIdentifiers)
        dispatchQueue = DispatchQueue(label: identifier)
        cbCentralManager = CBCentralManager(delegate: centralManagerDelegate, queue: dispatchQueue, options: [
            CBCentralManagerOptionRestoreIdentifierKey : identifier,
            CBCentralManagerOptionShowPowerAlertKey : true
        ])
    }
    
    deinit {
        if (cbCentralManager.state == .poweredOn) {
            cbCentralManager.stopScan()
        }
        cbCentralManager.delegate = nil
        os_log("deinit (%s)", log: log, type: .debug, identifier)
    }
    
    func scan() {
        os_log("scan ==================================================", log: log, type: .debug)
        centralManagerDelegate.centralManager(scan: cbCentralManager)
    }
}

class CentralManagerDelegate: NSObject, CBCentralManagerDelegate, CBPeripheralDelegate {
    private let log: OSLog
    private let identifier: String
    private let serviceUUIDs: [CBUUID]
    private var cbPeripherals: Set<CBPeripheral> = []
    private var cbCentralManager: CBCentralManager?
    var peripheralIdentifiers: [UUID] = []

    init(_ identifier: String, serviceUUIDs: [CBUUID], peripheralIdentifiers: [UUID]) {
        log = OSLog(subsystem: "Beacon", category: "CentralManager(" + identifier + ")")
        os_log("init.delegate (%s,%s)", log: log, type: .debug, identifier, peripheralIdentifiers.description)
        self.identifier = identifier
        self.serviceUUIDs = serviceUUIDs
        self.peripheralIdentifiers = peripheralIdentifiers
    }
    
    deinit {
        cbPeripherals.forEach() { peripheral in
            peripheral.delegate = nil
        }
        cbPeripherals.removeAll()
        os_log("deinit.delegate (%s)", log: log, type: .debug, identifier)
    }
    
    func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) {
        os_log("willRestoreState (%s)", log: log, type: .debug, central.description)
        cbCentralManager = central
        central.delegate = self
        if let restoredPeripherals = dict[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] {
            for peripheral in restoredPeripherals {
                os_log("willRestoreState -> register (%s)", log: log, type: .debug, peripheral.description)
                centralManager(register: peripheral)
            }
        }
    }

    private func centralManager(register peripheral: CBPeripheral) {
        os_log("register (%s)", log: log, type: .debug, peripheral.description)
        peripheral.delegate = self
        cbPeripherals.insert(peripheral)
        if !peripheralIdentifiers.contains(peripheral.identifier) {
            peripheralIdentifiers.append(peripheral.identifier)
        }
    }
    
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        cbCentralManager = central
        guard central.state == .poweredOn else {
            os_log("didUpdateState (%s)", log: self.log, type: .info, central.description)
            return
        }
        os_log("didUpdateState -> scan (%s)", log: self.log, type: .debug, central.description)
        centralManager(scan: central)
    }
    
    open func centralManager(scan central: CBCentralManager) {
        guard central.state == .poweredOn else {
            os_log("scan !poweredOn (%s)", log: log, type: .fault, central.description)
            return
        }
        os_log("scan -> didDiscover (%s)", log: log, type: .debug, central.description)
        central.scanForPeripherals(withServices: serviceUUIDs)
        central.retrievePeripherals(withIdentifiers: peripheralIdentifiers).forEach() { peripheral in
            os_log("scan:known (%s)", log: log, type: .debug, peripheral.description)
            centralManager(central, connect: peripheral)
        }
    }
    
    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
        os_log("didDiscover -> connect (%s,%s)", log: log, type: .debug, central.description, peripheral.description)
        centralManager(central, connect: peripheral)
    }

    func centralManager(_ central: CBCentralManager, connect peripheral: CBPeripheral) {
        os_log("connect -> register, didConnect|didFailToConnect (%s,%s)", log: log, type: .debug, central.description, peripheral.description)
        centralManager(register: peripheral)
        central.connect(peripheral)
    }

    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        os_log("didConnect -> didReadRSSI (%s,%s)", log: log, type: .debug, central.description, peripheral.description)
        peripheral.readRSSI()
    }

    func peripheral(_ peripheral: CBPeripheral, didReadRSSI RSSI: NSNumber, error: Error?) {
        let rssi = RSSI.intValue
        guard let central = cbCentralManager else {
            os_log("didReadRSSI !missingCentral (rssi=%s,error=%s,%s)", log: log, type: .fault, rssi.description, error?.localizedDescription ?? "nil", peripheral.description)
            return
        }
        os_log("didReadRSSI -> disconnect (rssi=%s,error=%s,%s)", log: log, type: .debug, rssi.description, error?.localizedDescription ?? "nil", peripheral.description)
        centralManager(central, disconnect: peripheral)
    }
    
    private func centralManager(_ central: CBCentralManager, disconnect peripheral: CBPeripheral) {
        os_log("disconnect -> didDisconnectPeripheral (%s,%s)", log: log, type: .debug, central.description, peripheral.description)
        central.cancelPeripheralConnection(peripheral)
    }

    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
        os_log("didDisconnectPeripheral -> unregister (error=%s,%s,%s)", log: log, type: .debug, error?.localizedDescription ?? "nil", central.description, peripheral.description)
        //centralManager(unregister: peripheral)
    }

    private func centralManager(unregister peripheral: CBPeripheral) {
        os_log("unregister (%s)", log: log, type: .debug, peripheral.description)
        peripheral.delegate = nil
        cbPeripherals.remove(peripheral)
    }

    func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
        os_log("didFailToConnect -> unregister (error=%s,%s,%s)", log: log, type: .debug, error?.localizedDescription ?? "nil", central.description, peripheral.description)
        centralManager(unregister: peripheral)
    }
    
    func centralManager(_ central: CBCentralManager, connectionEventDidOccur event: CBConnectionEvent, for peripheral: CBPeripheral) {
        os_log("connectionEventDidOccur (event=%s,%s)", log: log, type: .debug, event.description, peripheral.description)
    }
}

class PeripheralManager: NSObject {
    private let identifier: String
    private let peripheralManagerDelegate: PeripheralManagerDelegate
    private let log: OSLog
    private let dispatchQueue: DispatchQueue
    private let cbPeripheralManager: CBPeripheralManager
    open override var description: String { get {
        return "<PeripheralManager-" + addressString + ":identifer=" + identifier + ",state=" + cbPeripheralManager.state.description + ">"
    }}

    init(_ identifier: String, serviceUUID: CBUUID, code: BeaconCode) {
        log = OSLog(subsystem: "Beacon", category: "PeripheralManager(" + identifier + ")")
        os_log("init (%s)", log: log, type: .debug, identifier)
        self.identifier = identifier
        self.peripheralManagerDelegate = PeripheralManagerDelegate(identifier, serviceUUID: serviceUUID, code: code)
        dispatchQueue = DispatchQueue(label: identifier)
        cbPeripheralManager = CBPeripheralManager(delegate: peripheralManagerDelegate, queue: dispatchQueue, options: [
            CBPeripheralManagerOptionRestoreIdentifierKey : identifier,
            CBPeripheralManagerOptionShowPowerAlertKey : true
        ])
    }
    
    deinit {
        if cbPeripheralManager.state == .poweredOn {
            cbPeripheralManager.stopAdvertising()
        }
        cbPeripheralManager.delegate = nil
        os_log("deinit (%s)", log: log, type: .debug, identifier)
    }
}

class PeripheralManagerDelegate: NSObject, CBPeripheralManagerDelegate {
    private let identifier: String
    private let serviceUUID: CBUUID
    private let code: BeaconCode
    private let log: OSLog
    private var cbCentrals: Set<CBCentral> = []
    private var cbMutableService: CBMutableService?
    private var cbMutableCharacteristic: CBMutableCharacteristic?

    init(_ identifier: String, serviceUUID: CBUUID, code: BeaconCode) {
        log = OSLog(subsystem: "Beacon", category: "PeripheralManager(" + identifier + ")")
        os_log("init.delegate (%s)", log: log, type: .debug, identifier)
        self.identifier = identifier
        self.serviceUUID = serviceUUID
        self.code = code
    }
    
    deinit {
        cbMutableCharacteristic = nil
        cbMutableService = nil
        cbCentrals.removeAll()
        os_log("deinit.delegate (%s)", log: log, type: .debug, identifier)
    }

    func peripheralManager(_ peripheral: CBPeripheralManager, willRestoreState dict: [String : Any]) {
        os_log("willRestoreState", log: log, type: .debug)
        peripheral.delegate = self
        if let services = dict[CBPeripheralManagerRestoredStateServicesKey] as? [CBMutableService] {
            for service in services {
                if let characteristics = service.characteristics {
                    for characteristic in characteristics {
                        if characteristic.uuid.values.upper == beaconCharacteristicCBUUID.values.upper, let characteristic = characteristic as? CBMutableCharacteristic {
                            cbMutableService = service
                            cbMutableCharacteristic = characteristic
                            os_log("willRestoreState -> restored (%s,%s)", log: log, type: .debug, service.description, characteristic.description)
                        }
                    }
                }
            }
        }
    }

    func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) {
        guard peripheral.state == .poweredOn else {
            os_log("didUpdateState (%s)", log: log, type: .info, peripheral.description)
            return
        }
        os_log("didUpdateState -> startAdvertising (%s)", log: log, type: .debug, peripheral.description)
        peripheralManager(startAdvertising: peripheral)
    }
    
    private func peripheralManager(startAdvertising peripheral: CBPeripheralManager) {
        os_log("startAdvertising -> didStartAdvertising (%s)", log: self.log, type: .debug, peripheral.description)
        guard peripheral.state == .poweredOn else {
            return
        }
        let upper = beaconCharacteristicCBUUID.values.upper
        let beaconCharacteristicCBUUID = CBUUID(upper: upper, lower: code)
        let characteristic = CBMutableCharacteristic(type: beaconCharacteristicCBUUID, properties: [.write, .notify], value: nil, permissions: [.writeable])
        let service = CBMutableService(type: serviceUUID, primary: true)
        service.characteristics = [characteristic]
        peripheral.stopAdvertising()
        peripheral.removeAllServices()
        peripheral.add(service)
        peripheral.startAdvertising([CBAdvertisementDataServiceUUIDsKey : [serviceUUID]])
        cbMutableService = service
        cbMutableCharacteristic = characteristic
    }
    
    func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) {
        os_log("didStartAdvertising (error=%s,%s,%s,%s)", log: log, type: .debug, error?.localizedDescription ?? "nil", peripheral.description, cbMutableService?.description ?? "nil", cbMutableCharacteristic?.description ?? "nil")
    }
}


//
//    func peripheralManager(_ peripheral: CBPeripheralManager, central: CBCentral, didSubscribeTo characteristic: CBCharacteristic) {
//        os_log("peripheralManager:didSubscribeTo (%s)", log: log, type: .debug, central.description)
//        // Enables airplane mode survival for a while
//        peripheralManagerUpdateValue(peripheral)
//    }
//
//    func peripheralManager(_ peripheral: CBPeripheralManager, central: CBCentral, didUnsubscribeFrom characteristic: CBCharacteristic) {
//        os_log("peripheralManager:didUnsubscribeFrom (%s)", log: log, type: .debug, central.description)
//    }
//
//    func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveWrite requests: [CBATTRequest]) {
//        let centrals = requests.map{$0.central}
//        os_log("peripheralManager:didReceiveWrite (centrals=%s)", log: log, type: .debug, centrals.description)
//    }
//
//    func peripheralManagerUpdateValue(_ peripheral: CBPeripheralManager) {
//        os_log("peripheralManagerUpdateValue", log: log, type: .debug)
//        guard let characteristic = peripheralCharacteristic else {
//            return
//        }
//        peripheral.updateValue(emptyData, for: characteristic, onSubscribedCentrals: nil)
//    }
//
//    func peripheralManagerIsReady(toUpdateSubscribers peripheral: CBPeripheralManager) {
//        os_log("peripheralManagerIsReady:toUpdateSubscribers -> peripheralManagerUpdateValue", log: log, type: .debug)
//        peripheralManagerUpdateValue(peripheral)
//    }
//

class TestTransceiver: NSObject, Transceiver, CBPeripheralManagerDelegate, LocationManagerDelegate {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "TestTransceiver")
    private let beaconServiceUUID = BeaconServiceUUID()
    private let beaconCode: BeaconCode
    private let settings: Settings
    private let dispatchQueue = DispatchQueue(label: "Transceiver")
    private let emptyData = Data(repeating: 0, count: 0)

    private var delegates: [ReceiverDelegate] = []

    private var cbPeripheralManager: CBPeripheralManager!
    private var peripheralManager: [PeripheralManager] = []
    private var centralManager: [CentralManager] = []
    private var peripheralIdentifiers: [UUID] = []
    
    private let locationManager: LocationManager = ConcreteLocationManager()

    init(_ beaconCode: BeaconCode, _ settings: Settings) {
        self.beaconCode = beaconCode
        self.settings = settings
        super.init()
        locationManager.append(self)
        cbPeripheralManager = CBPeripheralManager(delegate: self, queue: dispatchQueue, options: [
            CBPeripheralManagerOptionShowPowerAlertKey : true
        ])
    }
    
    func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) {
        os_log("didUpdateState (%s)", log: self.log, type: .debug, peripheral.description)
        refresh()
    }
    
    private func refresh() {
        centralManager.last?.peripheralIdentifiers.forEach() { uuid in
            if !peripheralIdentifiers.contains(uuid) {
                peripheralIdentifiers.append(uuid)
            }
        }
        centralManager.removeAll()
        peripheralManager.removeAll()
        if cbPeripheralManager.state == .poweredOn {
            let identifier = Date().description
            //peripheralManager.append(PeripheralManager(identifier, serviceUUID: beaconServiceUUID.next, code: beaconCode))
            centralManager.append(CentralManager(identifier, serviceUUIDs: beaconServiceUUID.most, peripheralIdentifiers: peripheralIdentifiers))
        }
    }
    
    func start(_ source: String) {}
    
    func stop(_ source: String) {}
    
    func append(_ delegate: ReceiverDelegate) {
        delegates.append(delegate)
    }

    // MARK:- LocationManagerDelegate
    
    func locationManager(didDetect: LocationChange) {
        guard didDetect == .location else {
            return
        }
        os_log("locationManager:didDetect (change=%s)", log: self.log, type: .debug, didDetect.rawValue)
        refresh()
//        let centralManager = CentralManager(Date().description)
//        centralManagers.append(centralManager)
//        centralManager.scan()
    }
    
    // MARK:- CBPeripheralManagerDelegate
    
    
//    // MARK:- CBPeripheralDelegate
//
//    func peripheral(_ peripheral: CBPeripheral, didReadRSSI RSSI: NSNumber, error: Error?) {
//        let rssi = RSSI.intValue
//        os_log("peripheral:didReadRSSI -> cancelPeripheralConnection (rssi=%s,%s)", log: log, type: .debug, rssi.description, peripheral.description)
//        centralManager.cancelPeripheralConnection(peripheral)
////        if centralManagerCachedBeaconData[uuid] == nil {
////            centralManagerCachedBeaconData[uuid] = CachedBeaconData()
////        }
////        centralManagerCachedBeaconData[uuid]?.rssi = rssi
////        peripheral.discoverServices(beaconServiceUUID.all)
//    }
//
//    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
//        guard let service = peripheral.services?.filter({beaconServiceUUID.all.contains($0.uuid)}).first else {
//            os_log("peripheral:didDiscoverServices -> cancelPeripheralConnection (%s)", log: log, type: .debug, peripheral.description)
//            centralManager.cancelPeripheralConnection(peripheral)
//            return
//        }
//        os_log("peripheral:didDiscoverServices -> discoverCharacteristics (%s,%s)", log: log, type: .debug, peripheral.description, service.description)
//        peripheral.discoverCharacteristics(nil, for: service)
//    }
//
//    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
//        os_log("peripheral:didDiscoverCharacteristicsFor (%s)", log: log, type: .debug, peripheral.description)
//        guard let characteristic = service.characteristics?.filter({ $0.uuid.values.upper == beaconCharacteristicCBUUID.values.upper }).first else {
//            os_log("peripheral:didDiscoverCharacteristicsFor -> cancelPeripheralConnection (%s)", log: log, type: .debug, peripheral.description)
//            centralManager.cancelPeripheralConnection(peripheral)
//            return
//        }
//        let code = BeaconCode(characteristic.uuid.values.lower)
//        os_log("peripheral:didDiscoverCharacteristicsFor -> FOUND (%s,code=%s)", log: log, type: .debug, peripheral.description, code.description)
//        if characteristic.properties.contains(.notify) {
//            os_log("peripheral:didDiscoverCharacteristicsFor:ios -> setNotifyValue (%s)", log: log, type: .debug, peripheral.description)
//            peripheral.setNotifyValue(true, for: characteristic)
//        } else {
//            os_log("peripheral:didDiscoverCharacteristicsFor:android -> cancelPeripheralConnection (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
//            centralManager.cancelPeripheralConnection(peripheral)
//        }
//        // Notify delegates
//        if centralManagerCachedBeaconData[peripheral.identifier.uuidString] == nil {
//            centralManagerCachedBeaconData[peripheral.identifier.uuidString] = CachedBeaconData()
//            centralManagerCachedBeaconData[peripheral.identifier.uuidString]?.code = code
//        }
//        if let rssi = centralManagerCachedBeaconData[peripheral.identifier.uuidString]?.rssi {
//            delegates.forEach{$0.receiver(didDetect: code, rssi: rssi)}
//        }
//    }
//
//    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
//        os_log("peripheral:didUpdateValueFor (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
//    }
//
//    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) {
//        os_log("peripheral:didUpdateNotificationStateFor (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
//    }
//
//    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
//        os_log("peripheral:didWriteValueFor (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
//    }
//
//    func peripheral(_ peripheral: CBPeripheral, didModifyServices invalidatedServices: [CBService]) {
//        os_log("peripheral:didModifyServices (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
//    }
}

// MARK:- Extensions

extension NSObject {
    var addressString: String { get { Unmanaged.passUnretained(self).toOpaque().debugDescription.suffix(4).description }}
}

extension CBCentralManager {
    open override var description: String { get {
        return "<CBCentralManager-" + addressString + ":state=" + state.description + ">"
    }}
}

extension CBPeripheralManager {
    open override var description: String { get {
        return "<CBPeripheralManager-" + addressString + ":state=" + state.description + ">"
    }}
}

extension CBPeripheral {
    var uuidString: String { get { identifier.uuidString }}
    open override var description: String { get {
        return "<CBPeripheral-" + addressString + ":uuid=" + uuidString + ",state=" + state.description + ">"
    }}
}

extension CBCentral {
    var uuidString: String { get { identifier.uuidString }}
    open override var description: String { get {
        return "<CBCentral-" + addressString + ":uuid=" + uuidString + ">"
    }}
}

extension CBService {
    var uuidString: String { get { uuid.uuidString }}
    open override var description: String { get {
        return "<CBService-" + addressString + ":uuid=" + uuidString + ">"
    }}
}

extension CBMutableService {
    open override var description: String { get {
        return "<CBMutableService-" + addressString + ":uuid=" + uuidString + ">"
    }}
}

extension CBMutableCharacteristic {
    var uuidString: String { get { uuid.uuidString }}
    open override var description: String { get {
        let code = uuid.values.lower.description
        let centrals = subscribedCentrals?.description ?? "[]"
        return "<CBMutableCharacteristic-" + addressString + ":uuid=" + uuidString + ",code=" + code + ",subscribers=" + centrals + ">"
    }}
}

extension CBConnectionEvent {
    var description: String { get {
        switch self {
        case .peerConnected: return ".peerConnected"
        case .peerDisconnected: return ".peerDisconnected"
        @unknown default: return "unknown"
        }
    }}
}

class BeaconServiceUUID : NSObject {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "BeaconServiceUUID")
    let uuidStrings = [
        "00000000-0000-0000-0000-00000000007C",
        "00000000-0000-0000-0000-000000000037",
        "00000000-0000-0000-0000-00000000006E",
        "00000000-0000-0000-0000-000000000025",
        "00000000-0000-0000-0000-000000000059",
        "00000000-0000-0000-0000-000000000012",
        "00000000-0000-0000-0000-00000000004B"
//        "00000000-0000-0000-0000-000000000000",
//        "00000000-0000-0000-0000-000000000036",
//        "00000000-0000-0000-0000-00000000007D",
//        "00000000-0000-0000-0000-000000000024",
//        "00000000-0000-0000-0000-00000000006F",
//        "00000000-0000-0000-0000-000000000013",
//        "00000000-0000-0000-0000-000000000058",
//        "00000000-0000-0000-0000-000000000001",
//        "00000000-0000-0000-0000-00000000004A",
//        "00000000-0000-0000-0000-00000000006C",
//        "00000000-0000-0000-0000-000000000027",
//        "00000000-0000-0000-0000-00000000007E",
//        "00000000-0000-0000-0000-000000000035",
//        "00000000-0000-0000-0000-000000000049",
//        "00000000-0000-0000-0000-000000000002",
//        "00000000-0000-0000-0000-00000000005B",
//        "00000000-0000-0000-0000-000000000010",
//        "00000000-0000-0000-0000-000000000026",
//        "00000000-0000-0000-0000-00000000006D",
//        "00000000-0000-0000-0000-000000000034",
//        "00000000-0000-0000-0000-00000000007F",
//        "00000000-0000-0000-0000-000000000003",
//        "00000000-0000-0000-0000-000000000048",
//        "00000000-0000-0000-0000-000000000011",
//        "00000000-0000-0000-0000-00000000005A",
//        "00000000-0000-0000-0000-00000000005D",
//        "00000000-0000-0000-0000-000000000016",
//        "00000000-0000-0000-0000-00000000004F",
//        "00000000-0000-0000-0000-000000000004",
//        "00000000-0000-0000-0000-000000000078",
//        "00000000-0000-0000-0000-000000000033",
//        "00000000-0000-0000-0000-00000000006A",
//        "00000000-0000-0000-0000-000000000021",
//        "00000000-0000-0000-0000-000000000017",
//        "00000000-0000-0000-0000-00000000005C",
//        "00000000-0000-0000-0000-000000000005",
//        "00000000-0000-0000-0000-00000000004E",
//        "00000000-0000-0000-0000-000000000032",
//        "00000000-0000-0000-0000-000000000079",
//        "00000000-0000-0000-0000-000000000020",
//        "00000000-0000-0000-0000-00000000006B",
//        "00000000-0000-0000-0000-00000000004D",
//        "00000000-0000-0000-0000-000000000006",
//        "00000000-0000-0000-0000-00000000005F",
//        "00000000-0000-0000-0000-000000000014",
//        "00000000-0000-0000-0000-000000000068",
//        "00000000-0000-0000-0000-000000000023",
//        "00000000-0000-0000-0000-00000000007A",
//        "00000000-0000-0000-0000-000000000031",
//        "00000000-0000-0000-0000-000000000007",
//        "00000000-0000-0000-0000-00000000004C",
//        "00000000-0000-0000-0000-000000000015",
//        "00000000-0000-0000-0000-00000000005E",
//        "00000000-0000-0000-0000-000000000022",
//        "00000000-0000-0000-0000-000000000069",
//        "00000000-0000-0000-0000-000000000030",
//        "00000000-0000-0000-0000-00000000007B",
//        "00000000-0000-0000-0000-00000000003E",
//        "00000000-0000-0000-0000-000000000075",
//        "00000000-0000-0000-0000-00000000002C",
//        "00000000-0000-0000-0000-000000000067",
//        "00000000-0000-0000-0000-00000000001B",
//        "00000000-0000-0000-0000-000000000050",
//        "00000000-0000-0000-0000-000000000009",
//        "00000000-0000-0000-0000-000000000042",
//        "00000000-0000-0000-0000-000000000074",
//        "00000000-0000-0000-0000-00000000003F",
//        "00000000-0000-0000-0000-000000000066",
//        "00000000-0000-0000-0000-00000000002D",
//        "00000000-0000-0000-0000-000000000051",
//        "00000000-0000-0000-0000-00000000001A",
//        "00000000-0000-0000-0000-000000000043",
//        "00000000-0000-0000-0000-000000000008",
//        "00000000-0000-0000-0000-00000000002E",
//        "00000000-0000-0000-0000-000000000065",
//        "00000000-0000-0000-0000-00000000003C",
//        "00000000-0000-0000-0000-000000000077",
//        "00000000-0000-0000-0000-00000000000B",
//        "00000000-0000-0000-0000-000000000040",
//        "00000000-0000-0000-0000-000000000019",
//        "00000000-0000-0000-0000-000000000052",
//        "00000000-0000-0000-0000-000000000064",
//        "00000000-0000-0000-0000-00000000002F",
//        "00000000-0000-0000-0000-000000000076",
//        "00000000-0000-0000-0000-00000000003D",
//        "00000000-0000-0000-0000-000000000041",
//        "00000000-0000-0000-0000-00000000000A",
//        "00000000-0000-0000-0000-000000000053",
//        "00000000-0000-0000-0000-000000000018",
//        "00000000-0000-0000-0000-00000000001F",
//        "00000000-0000-0000-0000-000000000054",
//        "00000000-0000-0000-0000-00000000000D",
//        "00000000-0000-0000-0000-000000000046",
//        "00000000-0000-0000-0000-00000000003A",
//        "00000000-0000-0000-0000-000000000071",
//        "00000000-0000-0000-0000-000000000028",
//        "00000000-0000-0000-0000-000000000063",
//        "00000000-0000-0000-0000-000000000055",
//        "00000000-0000-0000-0000-00000000001E",
//        "00000000-0000-0000-0000-000000000047",
//        "00000000-0000-0000-0000-00000000000C",
//        "00000000-0000-0000-0000-000000000070",
//        "00000000-0000-0000-0000-00000000003B",
//        "00000000-0000-0000-0000-000000000062",
//        "00000000-0000-0000-0000-000000000029",
//        "00000000-0000-0000-0000-00000000000F",
//        "00000000-0000-0000-0000-000000000044",
//        "00000000-0000-0000-0000-00000000001D",
//        "00000000-0000-0000-0000-000000000056",
//        "00000000-0000-0000-0000-00000000002A",
//        "00000000-0000-0000-0000-000000000061",
//        "00000000-0000-0000-0000-000000000038",
//        "00000000-0000-0000-0000-000000000073",
//        "00000000-0000-0000-0000-000000000045",
//        "00000000-0000-0000-0000-00000000000E",
//        "00000000-0000-0000-0000-000000000057",
//        "00000000-0000-0000-0000-00000000001C",
//        "00000000-0000-0000-0000-000000000060",
//        "00000000-0000-0000-0000-00000000002B",
//        "00000000-0000-0000-0000-000000000072",
//        "00000000-0000-0000-0000-000000000039"
    ]
    let all: [CBUUID]!
    private var index = 0
    var current: CBUUID { get {
        all[index]
        
    }}
    var next: CBUUID { get {
        index = (index + 1) % all.count
        os_log("beaconServiceUUID:next (index=%s)", log: log, type: .debug, index.description)
        return current
    }}
    var most: [CBUUID] { get {
        var most: [CBUUID] = []
        index = (index + 1) % all.count
        let exclude = all.count - 1 - index
        for i in 0 ..< all.count {
            if i != exclude {
                most.append(all[i])
            }
        }
        os_log("beaconServiceUUID:most (exclude=%s)", log: log, type: .debug, exclude.description)
        return most
    }}
    
    override init() {
        all = uuidStrings.compactMap({CBUUID(string: $0)})
    }
    
}
