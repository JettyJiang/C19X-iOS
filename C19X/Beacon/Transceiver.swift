//
//  Transceiver.swift
//  C19X
//
//  Created by Freddy Choi on 01/04/2020.
//  Copyright Â© 2020 C19X. All rights reserved.
//

import Foundation
import CoreBluetooth
import os

/**
 Beacon transmitter and receiver for broadcasting and detecting frequently changing beacon codes
 that can be later resolved for on-device matching based on the daily beacon code seeds.
 
 Each registered device has a single shared secret that is generated and obtained from the server
 on registration. This is a one-off operation. The shared secret is then stored at the server and also
 in secure storage on the device. A sequence of day codes is then generated from the shared secret
 by recursively applying SHA to the hashes, and running the sequence in reverse to provide a finite
 list of forward secure codes, where historic codes cannot predict future codes. One day code is used
 per day. The daily beacon code seed is generated by reversing the day code binary data, and applying
 SHA to generate a hash as the seed. This separates the seed from the day code, and it is this seed
 that is being published by the central server later when a user submits their infection status, i.e.
 the published seed data cannot be reconnected to the day codes.
 
 Beacon codes for a day are generated by recursively hashing the daily beacon code seed to produce
 a collection of hashes, and the actual code is a long value produced by taking the modulo of each hash.
 This scheme makes it possible for the beacon codes to be regenerated on-device for matching given
 the daily seed codes.
 
 When a user submits his/her infection status, only the public identifier and infection status is transmitted
 to the central server. Given all the day codes are generated from the shared secret, the central server is
 able to generate and publish the relevant daily beacon seed codes for any time period for download by
 all the devices, which in turn can use the seed codes to generate the beacon codes for on-device
 matching. Given the original shared secret is shared only once via HTTPS and then stored securely
 on the server side, and also on the device, this scheme offers a small attack surface for decoding all
 the beacon codes.
 */
protocol Transceiver {
    /**
     Start transmitter and receiver to follow Bluetooth state changes to start and stop advertising and scanning.
     */
    func start(_ source: String)
    
    /**
     Stop transmitter and receiver will disable advertising, scanning and terminate all connections.
     */
    func stop(_ source: String)
    
    func append(_ delegate: ReceiverDelegate)
}

/// Time delay between notifications for subscribers.
let transceiverNotificationDelay = DispatchTimeInterval.seconds(8)

class ConcreteTransceiver: NSObject, Transceiver, LocationManagerDelegate {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "Transceiver")
    private let dayCodes: DayCodes
    private let beaconCodes: BeaconCodes
    private let queue = DispatchQueue(label: "org.c19x.beacon.Transceiver")
    private let transmitter: Transmitter
    private let receiver: Receiver
    private var delegates: [ReceiverDelegate] = []
    private let locationManager: LocationManager

    init(_ sharedSecret: SharedSecret, codeUpdateAfter: TimeInterval) {
        dayCodes = ConcreteDayCodes(sharedSecret)
        beaconCodes = ConcreteBeaconCodes(dayCodes)
        receiver = ConcreteReceiver(queue: queue)
        transmitter = ConcreteTransmitter(queue: queue, beaconCodes: beaconCodes, updateCodeAfter: codeUpdateAfter, receiver: receiver)
        locationManager = ConcreteLocationManager()
        super.init()
        locationManager.append(self)
    }
    
    func start(_ source: String) {
        os_log("start (source=%s)", log: self.log, type: .debug, source)
        transmitter.start(source)
        receiver.start(source)
        // REMOVE FOR PRODUCTION
        if source == "BGAppRefreshTask" {
            delegates.forEach { $0.receiver(didDetect: BeaconCode(0), rssi: RSSI(-10010)) }
        } else {
            delegates.forEach { $0.receiver(didDetect: BeaconCode(0), rssi: RSSI(-10000)) }
        }
    }

    func stop(_ source: String) {
        os_log("stop (source=%s)", log: self.log, type: .debug, source)
        transmitter.stop(source)
        receiver.stop(source)
    }
    
    func append(_ delegate: ReceiverDelegate) {
        delegates.append(delegate)
        receiver.append(delegate)
        transmitter.append(delegate)
    }
    
    // MARK:- LocationManagerDelegate
    
    func locationManager(didDetect: LocationChange) {
        receiver.scan("locationManager")
        os_log("Beacon state report (subscribers) ========", log: self.log, type: .debug)
        transmitter.subscribers().forEach() { central in
            os_log("Beacon state (uuid=%s,state=.subscribing)", log: self.log, type: .debug, central.identifier.uuidString)
        }
    }
}

class CachedBeaconData {
    var code: BeaconCode? {
        didSet {
            lastUpdatedAt = Date()
            codeUpdatedAt = Date()
        }
    }
    var rssi: RSSI? {
       didSet {
           lastUpdatedAt = Date()
       }
    }
    var codeUpdatedAt: Date = Date.distantPast
    var lastUpdatedAt: Date = Date.distantPast
}

class TestTransceiver: NSObject, Transceiver, LocationManagerDelegate, CBPeripheralManagerDelegate, CBCentralManagerDelegate, CBPeripheralDelegate {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "TestTransceiver")
    private let beaconServiceUUID = BeaconServiceUUID()
    private let beaconCode: BeaconCode
    private let settings: Settings
    private let dispatchQueue = DispatchQueue(label: "Transceiver")
    private let emptyData = Data(repeating: 0, count: 0)

    private var delegates: [ReceiverDelegate] = []

    private var peripheralManager: CBPeripheralManager!
    private var peripheralManagerService: CBMutableService?
    private var peripheralCharacteristic: CBMutableCharacteristic?
    
    private var centralManager: CBCentralManager!
    private var centralManagerPeripherals: Set<CBPeripheral> = []
    private var centralManagerPeripheralUuids: [UUID] = []
    private var centralManagerCachedBeaconData: [String:CachedBeaconData] = [:]
    
    private var centralManagerScanTimer: DispatchSourceTimer?
    private let centralManagerScanTimerQueue = DispatchQueue(label: "org.c19x.beacon.Timer")

    private var locationManager: LocationManager!

    init(_ beaconCode: BeaconCode, _ settings: Settings) {
        self.beaconCode = beaconCode
        self.settings = settings
        super.init()
        peripheralManager = CBPeripheralManager(delegate: self, queue: dispatchQueue, options: [
            CBPeripheralManagerOptionRestoreIdentifierKey : "org.C19X.beacon.Transmitter",
            CBPeripheralManagerOptionShowPowerAlertKey : true
        ])
        
        centralManager = CBCentralManager(delegate: self, queue: dispatchQueue, options: [
            CBCentralManagerOptionRestoreIdentifierKey : "org.C19X.beacon.Receiver",
            CBCentralManagerOptionShowPowerAlertKey : true
        ])
        
        locationManager = ConcreteLocationManager()
        locationManager.append(self)
    }
    
    func start(_ source: String) {}
    
    func stop(_ source: String) {}
    
    func append(_ delegate: ReceiverDelegate) {
        delegates.append(delegate)
    }

    // MARK:- LocationManagerDelegate
    
    func locationManager(didDetect: LocationChange) {
        guard didDetect == .location else {
            return
        }
        os_log("locationManager:didDetect (change=%s)", log: self.log, type: .debug, didDetect.rawValue)
        centralManagerScanForPeripherals(centralManager)
    }
    
    // MARK:- CBPeripheralManagerDelegate
    
    func peripheralManager(_ peripheral: CBPeripheralManager, willRestoreState dict: [String : Any]) {
        os_log("peripheralManager:willRestoreState", log: log, type: .debug)
        peripheralManager = peripheral
        peripheralManager.delegate = self
        if let services = dict[CBPeripheralManagerRestoredStateServicesKey] as? [CBMutableService] {
            for service in services {
                if let characteristics = service.characteristics {
                    for characteristic in characteristics {
                        if characteristic.uuid.values.upper == beaconCharacteristicCBUUID.values.upper, let characteristic = characteristic as? CBMutableCharacteristic {
                            peripheralManagerService = service
                            peripheralCharacteristic = characteristic
                            os_log("peripheralManager:willRestoreState -> restored (service=%s,characteristic=%s)", log: log, type: .debug, service.description, characteristic.description)
                        }
                    }
                }
            }
        }
    }

    func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) {
        os_log("peripheralManagerDidUpdateState (state=%s)", log: self.log, type: .debug, peripheral.state.description)
        delegates.forEach{$0.receiver(didUpdateState: peripheral.state)}
        guard peripheral.state == .poweredOn else {
            return
        }
        os_log("peripheralManagerDidUpdateState -> peripheralManagerStartAdvertising (state=%s)", log: self.log, type: .debug, peripheral.state.description)
        peripheralManagerStartAdvertising(peripheral, code: beaconCode)
    }
    
    private func peripheralManagerStartAdvertising(_ peripheral: CBPeripheralManager, code: BeaconCode) {
        os_log("peripheralManagerStartAdvertising -> startAdvertising (state=%s,code=%s)", log: self.log, type: .debug, peripheral.state.description, code.description)
        guard peripheral.state == .poweredOn else {
            return
        }
        peripheralManager = peripheral
        peripheralManager.delegate = self
        let upper = beaconCharacteristicCBUUID.values.upper
        let beaconCharacteristicCBUUID = CBUUID(upper: upper, lower: beaconCode)
        let characteristic = CBMutableCharacteristic(type: beaconCharacteristicCBUUID, properties: [.write, .notify], value: nil, permissions: [.writeable])
        let service = CBMutableService(type: beaconServiceUUID.next, primary: true)
        service.characteristics = [characteristic]
        peripheralManager.stopAdvertising()
        peripheralManager.removeAllServices()
        peripheralManager.add(service)
        peripheralManager.startAdvertising([CBAdvertisementDataServiceUUIDsKey : [service.uuid]])
        peripheralManagerService = service
        peripheralCharacteristic = characteristic
    }
    
    
    func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) {
        os_log("peripheralManagerDidStartAdvertising (service=%s,error=%s)", log: log, type: .debug, peripheralManagerService?.description ?? "nil", error?.localizedDescription ?? "nil")
    }
    
    func peripheralManager(_ peripheral: CBPeripheralManager, central: CBCentral, didSubscribeTo characteristic: CBCharacteristic) {
        os_log("peripheralManager:didSubscribeTo (%s)", log: log, type: .debug, central.description)
        // Enables airplane mode survival for a while
        peripheralManagerUpdateValue(peripheral)
    }
    
    func peripheralManager(_ peripheral: CBPeripheralManager, central: CBCentral, didUnsubscribeFrom characteristic: CBCharacteristic) {
        os_log("peripheralManager:didUnsubscribeFrom (%s)", log: log, type: .debug, central.description)
    }
    
    func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveWrite requests: [CBATTRequest]) {
        let centrals = requests.map{$0.central}
        os_log("peripheralManager:didReceiveWrite (centrals=%s)", log: log, type: .debug, centrals.description)
    }

    func peripheralManagerUpdateValue(_ peripheral: CBPeripheralManager) {
        os_log("peripheralManagerUpdateValue", log: log, type: .debug)
        guard let characteristic = peripheralCharacteristic else {
            return
        }
        peripheral.updateValue(emptyData, for: characteristic, onSubscribedCentrals: nil)
    }
    
    func peripheralManagerIsReady(toUpdateSubscribers peripheral: CBPeripheralManager) {
        os_log("peripheralManagerIsReady:toUpdateSubscribers -> peripheralManagerUpdateValue", log: log, type: .debug)
        peripheralManagerUpdateValue(peripheral)
    }
    
    // MARK:- CBCentralManagerDelegate
    
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        os_log("centralManagerDidUpdateState (state=%s)", log: self.log, type: .debug, central.state.description)
        guard central.state == .poweredOn else {
            return
        }
        centralManager = central
        centralManager.delegate = self
        centralManagerScanForPeripherals(central)
    }
    
    func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) {
        os_log("centralManager:willRestoreState", log: log, type: .debug)
        centralManager = central
        centralManager.delegate = self
        if let restoredPeripherals = dict[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] {
            for peripheral in restoredPeripherals {
                peripheral.delegate = self
                centralManagerPeripherals.insert(peripheral)
                os_log("centralManager:willRestoreState:restored (%s)", log: log, type: .debug, peripheral.description)
            }
        }
    }
    
    func centralManagerScanForPeripherals(_ central: CBCentralManager) {
        os_log("centralManager:scanForPeripherals (state=%s) ====================", log: log, type: .debug, central.state.description)
//        scheduleCentralManagerScanForPeripherals()
//        let identifiers = settings.peripherals().sorted{$0 < $1}.compactMap{UUID(uuidString: $0)}
//        central.retrieveConnectedPeripherals(withServices: [beaconServiceCBUUID]).forEach() { peripheral in
//            os_log("centralManager:scanForPeripherals:retrieveConnectedPeripherals -> connect (%s)", log: log, type: .debug, peripheral.description)
//            centralManagerPeripherals[peripheral.identifier.uuidString] = peripheral
//            guard central.state == .poweredOn else {
//                return
//            }
//            central.connect(peripheral)
//        }
//        // Enables resume from airplane mode
//        var peripherals: [CBPeripheral] = []
//        peripherals.append(contentsOf: central.retrievePeripherals(withIdentifiers: identifiers))
//        peripherals.forEach() { peripheral in
//            centralManagerPeripherals[peripheral.uuidString] = peripheral
//            guard central.state == .poweredOn else {
//                return
//            }
//            central.connect(peripheral)
//        }
        guard central.state == .poweredOn else {
            return
        }
        central.stopScan()
        os_log("centralManager:scanForPeripherals", log: log, type: .debug)
        central.scanForPeripherals(withServices: beaconServiceUUID.most)
        os_log("centralManager:centralManagerPeripherals", log: log, type: .debug)
        centralManagerPeripherals.forEach() { peripheral in
            os_log("centralManager:scanForPeripherals:centralManagerPeripherals (%s)", log: log, type: .debug, peripheral.description)
            centralManagerConnect(central, connect: peripheral)
        }
        os_log("centralManager:retrieveConnectedPeripherals", log: log, type: .debug)
        central.retrieveConnectedPeripherals(withServices: beaconServiceUUID.most).forEach() { peripheral in
            os_log("centralManager:scanForPeripherals:retrieveConnectedPeripherals (%s)", log: log, type: .debug, peripheral.description)
            centralManagerConnect(central, connect: peripheral)
        }
        os_log("centralManager:centralManagerPeripheralUuids (%s)", log: log, type: .debug, centralManagerPeripheralUuids.description)
        centralManagerPeripheralUuids.forEach() { uuid in
            os_log("centralManager:scanForPeripherals:centralManagerPeripheralUuids (%s)", log: log, type: .debug, uuid.description)
            central.retrievePeripherals(withIdentifiers: [uuid]).forEach() { peripheral in
                centralManagerConnect(central, connect: peripheral)
            }
        }
    }
    
    func centralManagerConnect(_ central: CBCentralManager, connect peripheral: CBPeripheral) {
        centralManagerPeripherals.insert(peripheral)
        if !centralManagerPeripheralUuids.contains(peripheral.identifier) {
            centralManagerPeripheralUuids.append(peripheral.identifier)
        }
        central.connect(peripheral)
    }
    
    func scheduleCentralManagerScanForPeripherals() {
        centralManagerScanTimer?.cancel()
        centralManagerScanTimer = DispatchSource.makeTimerSource(queue: centralManagerScanTimerQueue)
        // Schedule is held idle until didSubscribe
        centralManagerScanTimer?.schedule(deadline: DispatchTime.now().advanced(by: .seconds(8)))
        centralManagerScanTimer?.setEventHandler { [weak self] in
            guard let centralManager = self?.centralManager else {
                return
            }
            self?.centralManagerScanForPeripherals(centralManager)
        }
        centralManagerScanTimer?.resume()
    }

    
    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
        os_log("centralManager:didDiscover -> connect (%s)", log: log, type: .debug, peripheral.description)
        centralManagerConnect(central, connect: peripheral)
    }

    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        os_log("centralManager:didConnect -> readRSSI (%s)", log: log, type: .debug, peripheral.description)
        peripheral.delegate = self
        peripheral.readRSSI()
    }
    
    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
        os_log("centralManager:didDisconnectPeripheral (%s)", log: log, type: .debug, peripheral.description)
        centralManagerPeripherals.remove(peripheral)
        peripheral.delegate = nil
    }
    
    func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
        os_log("centralManager:didFailToConnect (%s)", log: log, type: .debug, peripheral.description)
        centralManagerPeripherals.remove(peripheral)
        peripheral.delegate = nil
    }
    
    // MARK:- CBPeripheralDelegate
    
    func peripheral(_ peripheral: CBPeripheral, didReadRSSI RSSI: NSNumber, error: Error?) {
        let rssi = RSSI.intValue
        os_log("peripheral:didReadRSSI -> cancelPeripheralConnection (rssi=%s,%s)", log: log, type: .debug, rssi.description, peripheral.description)
        centralManager.cancelPeripheralConnection(peripheral)
//        if centralManagerCachedBeaconData[uuid] == nil {
//            centralManagerCachedBeaconData[uuid] = CachedBeaconData()
//        }
//        centralManagerCachedBeaconData[uuid]?.rssi = rssi
//        peripheral.discoverServices(beaconServiceUUID.all)
    }
    
    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
        guard let service = peripheral.services?.filter({beaconServiceUUID.all.contains($0.uuid)}).first else {
            os_log("peripheral:didDiscoverServices -> cancelPeripheralConnection (%s)", log: log, type: .debug, peripheral.description)
            centralManager.cancelPeripheralConnection(peripheral)
            return
        }
        os_log("peripheral:didDiscoverServices -> discoverCharacteristics (%s,%s)", log: log, type: .debug, peripheral.description, service.description)
        peripheral.discoverCharacteristics(nil, for: service)
    }

    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        os_log("peripheral:didDiscoverCharacteristicsFor (%s)", log: log, type: .debug, peripheral.description)
        guard let characteristic = service.characteristics?.filter({ $0.uuid.values.upper == beaconCharacteristicCBUUID.values.upper }).first else {
            os_log("peripheral:didDiscoverCharacteristicsFor -> cancelPeripheralConnection (%s)", log: log, type: .debug, peripheral.description)
            centralManager.cancelPeripheralConnection(peripheral)
            return
        }
        let code = BeaconCode(characteristic.uuid.values.lower)
        os_log("peripheral:didDiscoverCharacteristicsFor -> FOUND (%s,code=%s)", log: log, type: .debug, peripheral.description, code.description)
        if characteristic.properties.contains(.notify) {
            os_log("peripheral:didDiscoverCharacteristicsFor:ios -> setNotifyValue (%s)", log: log, type: .debug, peripheral.description)
            peripheral.setNotifyValue(true, for: characteristic)
        } else {
            os_log("peripheral:didDiscoverCharacteristicsFor:android -> cancelPeripheralConnection (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
            centralManager.cancelPeripheralConnection(peripheral)
        }
        // Notify delegates
        if centralManagerCachedBeaconData[peripheral.identifier.uuidString] == nil {
            centralManagerCachedBeaconData[peripheral.identifier.uuidString] = CachedBeaconData()
            centralManagerCachedBeaconData[peripheral.identifier.uuidString]?.code = code
        }
        if let rssi = centralManagerCachedBeaconData[peripheral.identifier.uuidString]?.rssi {
            delegates.forEach{$0.receiver(didDetect: code, rssi: rssi)}
        }
    }
    
    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        os_log("peripheral:didUpdateValueFor (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
    }

    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) {
        os_log("peripheral:didUpdateNotificationStateFor (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
    }
    
    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
        os_log("peripheral:didWriteValueFor (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
    }
    
    func peripheral(_ peripheral: CBPeripheral, didModifyServices invalidatedServices: [CBService]) {
        os_log("peripheral:didModifyServices (uuid=%s)", log: log, type: .debug, peripheral.identifier.uuidString)
    }
}

extension CBPeripheral {
    var uuidString: String { get { identifier.uuidString }}
    open override var description: String { get {
        let stateString = state.description
        let objectIdentifier = Unmanaged.passUnretained(self).toOpaque().debugDescription.suffix(6).description
        return "<P:uuid=" + uuidString + ",state=" + stateString + ",obj=" + objectIdentifier + ">"
    }}
}

extension CBCentral {
    var uuidString: String { get { identifier.uuidString }}
    open override var description: String { get {
        let objectIdentifier = Unmanaged.passUnretained(self).toOpaque().debugDescription.suffix(6).description
        return "<C:uuid=" + uuidString + ",obj=" + objectIdentifier + ">"
    }}
}

extension CBService {
    var uuidString: String { get { uuid.uuidString }}
    open override var description: String { get {
        let objectIdentifier = Unmanaged.passUnretained(self).toOpaque().debugDescription.suffix(6).description
        return "<SERVICE:uuid=" + uuidString + ",obj=" + objectIdentifier + ">"
    }}
}

extension CBMutableService {
    open override var description: String { get {
        let objectIdentifier = Unmanaged.passUnretained(self).toOpaque().debugDescription.suffix(6).description
        return "<SERVICE:uuid=" + uuidString + ",obj=" + objectIdentifier + ">"
    }}
}

extension CBMutableCharacteristic {
    var uuidString: String { get { uuid.uuidString }}
    open override var description: String { get {
        let objectIdentifier = Unmanaged.passUnretained(self).toOpaque().debugDescription.suffix(6).description
        let code = uuid.values.lower.description
        let centrals = subscribedCentrals?.description ?? "[]"
        return "<CHAR:uuid=" + uuidString + ",code=" + code + ",subscribers=" + centrals + ",obj=" + objectIdentifier + ">"
    }}
}

class BeaconServiceUUID : NSObject {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "BeaconServiceUUID")
    let uuidStrings = [
        "00000000-0000-0000-0000-00000000007C",
        "00000000-0000-0000-0000-000000000037",
        "00000000-0000-0000-0000-00000000006E",
        "00000000-0000-0000-0000-000000000025",
        "00000000-0000-0000-0000-000000000059",
        "00000000-0000-0000-0000-000000000012",
        "00000000-0000-0000-0000-00000000004B",
        "00000000-0000-0000-0000-000000000000",
        "00000000-0000-0000-0000-000000000036",
        "00000000-0000-0000-0000-00000000007D",
        "00000000-0000-0000-0000-000000000024",
        "00000000-0000-0000-0000-00000000006F",
        "00000000-0000-0000-0000-000000000013",
        "00000000-0000-0000-0000-000000000058",
        "00000000-0000-0000-0000-000000000001",
        "00000000-0000-0000-0000-00000000004A",
        "00000000-0000-0000-0000-00000000006C",
        "00000000-0000-0000-0000-000000000027",
        "00000000-0000-0000-0000-00000000007E",
        "00000000-0000-0000-0000-000000000035",
        "00000000-0000-0000-0000-000000000049",
        "00000000-0000-0000-0000-000000000002",
        "00000000-0000-0000-0000-00000000005B",
        "00000000-0000-0000-0000-000000000010",
        "00000000-0000-0000-0000-000000000026",
        "00000000-0000-0000-0000-00000000006D",
        "00000000-0000-0000-0000-000000000034",
        "00000000-0000-0000-0000-00000000007F",
        "00000000-0000-0000-0000-000000000003",
        "00000000-0000-0000-0000-000000000048",
        "00000000-0000-0000-0000-000000000011",
        "00000000-0000-0000-0000-00000000005A",
        "00000000-0000-0000-0000-00000000005D",
        "00000000-0000-0000-0000-000000000016",
        "00000000-0000-0000-0000-00000000004F",
        "00000000-0000-0000-0000-000000000004",
        "00000000-0000-0000-0000-000000000078",
        "00000000-0000-0000-0000-000000000033",
        "00000000-0000-0000-0000-00000000006A",
        "00000000-0000-0000-0000-000000000021",
        "00000000-0000-0000-0000-000000000017",
        "00000000-0000-0000-0000-00000000005C",
        "00000000-0000-0000-0000-000000000005",
        "00000000-0000-0000-0000-00000000004E",
        "00000000-0000-0000-0000-000000000032",
        "00000000-0000-0000-0000-000000000079",
        "00000000-0000-0000-0000-000000000020",
        "00000000-0000-0000-0000-00000000006B",
        "00000000-0000-0000-0000-00000000004D",
        "00000000-0000-0000-0000-000000000006",
        "00000000-0000-0000-0000-00000000005F",
        "00000000-0000-0000-0000-000000000014",
        "00000000-0000-0000-0000-000000000068",
        "00000000-0000-0000-0000-000000000023",
        "00000000-0000-0000-0000-00000000007A",
        "00000000-0000-0000-0000-000000000031",
        "00000000-0000-0000-0000-000000000007",
        "00000000-0000-0000-0000-00000000004C",
        "00000000-0000-0000-0000-000000000015",
        "00000000-0000-0000-0000-00000000005E",
        "00000000-0000-0000-0000-000000000022",
        "00000000-0000-0000-0000-000000000069",
        "00000000-0000-0000-0000-000000000030",
        "00000000-0000-0000-0000-00000000007B",
        "00000000-0000-0000-0000-00000000003E",
        "00000000-0000-0000-0000-000000000075",
        "00000000-0000-0000-0000-00000000002C",
        "00000000-0000-0000-0000-000000000067",
        "00000000-0000-0000-0000-00000000001B",
        "00000000-0000-0000-0000-000000000050",
        "00000000-0000-0000-0000-000000000009",
        "00000000-0000-0000-0000-000000000042",
        "00000000-0000-0000-0000-000000000074",
        "00000000-0000-0000-0000-00000000003F",
        "00000000-0000-0000-0000-000000000066",
        "00000000-0000-0000-0000-00000000002D",
        "00000000-0000-0000-0000-000000000051",
        "00000000-0000-0000-0000-00000000001A",
        "00000000-0000-0000-0000-000000000043",
        "00000000-0000-0000-0000-000000000008",
        "00000000-0000-0000-0000-00000000002E",
        "00000000-0000-0000-0000-000000000065",
        "00000000-0000-0000-0000-00000000003C",
        "00000000-0000-0000-0000-000000000077",
        "00000000-0000-0000-0000-00000000000B",
        "00000000-0000-0000-0000-000000000040",
        "00000000-0000-0000-0000-000000000019",
        "00000000-0000-0000-0000-000000000052",
        "00000000-0000-0000-0000-000000000064",
        "00000000-0000-0000-0000-00000000002F",
        "00000000-0000-0000-0000-000000000076",
        "00000000-0000-0000-0000-00000000003D",
        "00000000-0000-0000-0000-000000000041",
        "00000000-0000-0000-0000-00000000000A",
        "00000000-0000-0000-0000-000000000053",
        "00000000-0000-0000-0000-000000000018",
        "00000000-0000-0000-0000-00000000001F",
        "00000000-0000-0000-0000-000000000054",
        "00000000-0000-0000-0000-00000000000D",
        "00000000-0000-0000-0000-000000000046",
        "00000000-0000-0000-0000-00000000003A",
        "00000000-0000-0000-0000-000000000071",
        "00000000-0000-0000-0000-000000000028",
        "00000000-0000-0000-0000-000000000063",
        "00000000-0000-0000-0000-000000000055",
        "00000000-0000-0000-0000-00000000001E",
        "00000000-0000-0000-0000-000000000047",
        "00000000-0000-0000-0000-00000000000C",
        "00000000-0000-0000-0000-000000000070",
        "00000000-0000-0000-0000-00000000003B",
        "00000000-0000-0000-0000-000000000062",
        "00000000-0000-0000-0000-000000000029",
        "00000000-0000-0000-0000-00000000000F",
        "00000000-0000-0000-0000-000000000044",
        "00000000-0000-0000-0000-00000000001D",
        "00000000-0000-0000-0000-000000000056",
        "00000000-0000-0000-0000-00000000002A",
        "00000000-0000-0000-0000-000000000061",
        "00000000-0000-0000-0000-000000000038",
        "00000000-0000-0000-0000-000000000073",
        "00000000-0000-0000-0000-000000000045",
        "00000000-0000-0000-0000-00000000000E",
        "00000000-0000-0000-0000-000000000057",
        "00000000-0000-0000-0000-00000000001C",
        "00000000-0000-0000-0000-000000000060",
        "00000000-0000-0000-0000-00000000002B",
        "00000000-0000-0000-0000-000000000072",
        "00000000-0000-0000-0000-000000000039"
    ]
    let all: [CBUUID]!
    private var index = 0
    var current: CBUUID { get {
        all[index]
        
    }}
    var next: CBUUID { get {
        index = (index + 1) % all.count
        os_log("beaconServiceUUID:next (index=%s)", log: log, type: .debug, index.description)
        return current
    }}
    var most: [CBUUID] { get {
        var most: [CBUUID] = []
        index = (index + 1) % all.count
        let exclude = all.count - 1 - index
        for i in 0 ..< all.count {
            if i != exclude {
                most.append(all[i])
            }
        }
        os_log("beaconServiceUUID:most (exclude=%s)", log: log, type: .debug, exclude.description)
        return most
    }}
    
    override init() {
        all = uuidStrings.compactMap({CBUUID(string: $0)})
    }
    
}
