//
//  Transceiver.swift
//  C19X
//
//  Created by Freddy Choi on 01/04/2020.
//  Copyright Â© 2020 C19X. All rights reserved.
//

import Foundation
import CoreBluetooth
import os

/**
 Beacon transmitter and receiver for broadcasting and detecting frequently changing beacon codes
 that can be later resolved for on-device matching based on the daily beacon code seeds.
 
 Each registered device has a single shared secret that is generated and obtained from the server
 on registration. This is a one-off operation. The shared secret is then stored at the server and also
 in secure storage on the device. A sequence of day codes is then generated from the shared secret
 by recursively applying SHA to the hashes, and running the sequence in reverse to provide a finite
 list of forward secure codes, where historic codes cannot predict future codes. One day code is used
 per day. The daily beacon code seed is generated by reversing the day code binary data, and applying
 SHA to generate a hash as the seed. This separates the seed from the day code, and it is this seed
 that is being published by the central server later when a user submits their infection status, i.e.
 the published seed data cannot be reconnected to the day codes.
 
 Beacon codes for a day are generated by recursively hashing the daily beacon code seed to produce
 a collection of hashes, and the actual code is a long value produced by taking the modulo of each hash.
 This scheme makes it possible for the beacon codes to be regenerated on-device for matching given
 the daily seed codes.
 
 When a user submits his/her infection status, only the public identifier and infection status is transmitted
 to the central server. Given all the day codes are generated from the shared secret, the central server is
 able to generate and publish the relevant daily beacon seed codes for any time period for download by
 all the devices, which in turn can use the seed codes to generate the beacon codes for on-device
 matching. Given the original shared secret is shared only once via HTTPS and then stored securely
 on the server side, and also on the device, this scheme offers a small attack surface for decoding all
 the beacon codes.
 */
protocol Transceiver {
    /**
     Start transmitter and receiver to follow Bluetooth state changes to start and stop advertising and scanning.
     */
    func start(_ source: String)
    
    /**
     Stop transmitter and receiver will disable advertising, scanning and terminate all connections.
     */
    func stop(_ source: String)
    
    func append(_ delegate: ReceiverDelegate)
}

/// Time delay between notifications for subscribers.
let transceiverNotificationDelay = DispatchTimeInterval.seconds(8)

class ConcreteTransceiver: NSObject, Transceiver, LocationManagerDelegate {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "Transceiver")
    private let dayCodes: DayCodes
    private let beaconCodes: BeaconCodes
    private let queue = DispatchQueue(label: "org.c19x.beacon.Transceiver")
    private let transmitter: Transmitter
    private let receiver: Receiver
    private var delegates: [ReceiverDelegate] = []
    private let locationManager: LocationManager

    init(_ sharedSecret: SharedSecret, codeUpdateAfter: TimeInterval) {
        dayCodes = ConcreteDayCodes(sharedSecret)
        beaconCodes = ConcreteBeaconCodes(dayCodes)
        receiver = ConcreteReceiver(queue: queue)
        transmitter = ConcreteTransmitter(queue: queue, beaconCodes: beaconCodes, updateCodeAfter: codeUpdateAfter, receiver: receiver)
        locationManager = ConcreteLocationManager()
        super.init()
        locationManager.append(self)
    }
    
    func start(_ source: String) {
        os_log("start (source=%s)", log: self.log, type: .debug, source)
        transmitter.start(source)
        receiver.start(source)
        // REMOVE FOR PRODUCTION
        if source == "BGAppRefreshTask" {
            delegates.forEach { $0.receiver(didDetect: BeaconCode(0), rssi: RSSI(-10010)) }
        } else {
            delegates.forEach { $0.receiver(didDetect: BeaconCode(0), rssi: RSSI(-10000)) }
        }
    }

    func stop(_ source: String) {
        os_log("stop (source=%s)", log: self.log, type: .debug, source)
        transmitter.stop(source)
        receiver.stop(source)
    }
    
    func append(_ delegate: ReceiverDelegate) {
        delegates.append(delegate)
        receiver.append(delegate)
        transmitter.append(delegate)
    }
    
    // MARK:- LocationManagerDelegate
    
    func locationManager(didDetect: LocationChange) {
        receiver.scan("locationManager")
        os_log("Beacon state report (subscribers) ========", log: self.log, type: .debug)
        transmitter.subscribers().forEach() { central in
            os_log("Beacon state (uuid=%s,state=.subscribing)", log: self.log, type: .debug, central.identifier.uuidString)
        }
    }
}

class CachedBeaconData {
    var rssi: RSSI? {
       didSet {
           lastUpdatedAt = Date()
       }
    }
    var operatingSystem: OperatingSystem? {
        didSet {
            lastUpdatedAt = Date()
        }
    }
    var code: BeaconCode? {
        didSet {
            lastUpdatedAt = Date()
            codeUpdatedAt = Date()
        }
    }
    var characteristic: CBCharacteristic? {
        didSet {
            lastUpdatedAt = Date()
        }
    }
    var codeUpdatedAt: Date = Date.distantPast
    var lastUpdatedAt: Date = Date.distantPast
    var codeIsValid: Bool { get {
        let today = UInt64(Date().timeIntervalSince1970).dividedReportingOverflow(by: UInt64(86400))
        let createdOnDay = UInt64(codeUpdatedAt.timeIntervalSince1970).dividedReportingOverflow(by: UInt64(86400))
        return createdOnDay == today
    }}
    var description: String { get {
        return "<Beacon: code = \(code?.description ?? "?"), os = \(operatingSystem?.rawValue ?? "?"), rssi = \(rssi?.description ?? "?"), lastUpdatedAt = \(lastUpdatedAt.description)>"
    }}
}

class TestTransceiver: NSObject, Transceiver, LocationManagerDelegate, CBPeripheralManagerDelegate, CBCentralManagerDelegate, CBPeripheralDelegate {
    private let log = OSLog(subsystem: "org.c19x.beacon", category: "TestTransceiver")
    private let beaconCode: BeaconCode
    private let settings: Settings
    private let dispatchQueue = DispatchQueue(label: "Transceiver")
    private let emptyData = Data(repeating: 0, count: 0)

    private var delegates: [ReceiverDelegate] = []

    private var peripheralManager: CBPeripheralManager! {
        willSet {
            peripheralManager.delegate = nil
        }
        didSet {
            peripheralManager.delegate = self
        }
    }
    private var peripheralManagerCharacteristic: CBMutableCharacteristic?
    
    private var centralManager: CBCentralManager! {
        willSet {
            centralManager.delegate = nil
        }
        didSet {
            centralManager.delegate = self
        }
    }
    private var centralManagerPeripherals: Set<CBPeripheral> = []
    private var centralManagerCachedBeaconData: [String:CachedBeaconData] = [:]
    
    private var centralManagerScanTimer: DispatchSourceTimer?
    private let timerQueue = DispatchQueue(label: "org.c19x.beacon.transceiver.timerQueue")
    private var centralManagerConnectTimer: [CBPeripheral:DispatchSourceTimer] = [:]

    private var locationManager: LocationManager!

    init(_ beaconCode: BeaconCode, _ settings: Settings) {
        self.beaconCode = beaconCode
        self.settings = settings
        super.init()
        peripheralManager = CBPeripheralManager(delegate: self, queue: dispatchQueue, options: [
            CBPeripheralManagerOptionRestoreIdentifierKey : "org.C19X.beacon.Transmitter",
            CBPeripheralManagerOptionShowPowerAlertKey : true
        ])
        centralManager = CBCentralManager(delegate: self, queue: dispatchQueue, options: [
            CBCentralManagerOptionRestoreIdentifierKey : "org.C19X.beacon.Receiver",
            CBCentralManagerOptionShowPowerAlertKey : true
        ])
        locationManager = ConcreteLocationManager()
        locationManager.append(self)
    }
    
    func start(_ source: String) {}
    
    func stop(_ source: String) {}
    
    func append(_ delegate: ReceiverDelegate) {
        delegates.append(delegate)
    }
    
    // MARK:- CBCentralManager extensions
    
    private func centralManager(register peripheral: CBPeripheral) {
        peripheral.delegate = self
        if centralManagerPeripherals.insert(peripheral).inserted {
            os_log("centralManager:register (peripheral=%s)", log: self.log, type: .debug, peripheral.description)
        }
    }
    
    private func centralManager(deregister peripheral: CBPeripheral) {
        peripheral.delegate = nil
        if centralManagerPeripherals.remove(peripheral) != nil {
            os_log("centralManager:deregister (peripheral=%s)", log: self.log, type: .debug, peripheral.description)
        }
    }
    
    private func centralManager(connect peripheral: CBPeripheral) {
        centralManager(register: peripheral)
        centralManagerConnectTimer[peripheral]?.cancel()
        let timer = DispatchSource.makeTimerSource(queue: timerQueue)
        centralManagerConnectTimer[peripheral] = timer
        timer.schedule(deadline: DispatchTime.now().advanced(by: .seconds(4)))
        let log = self.log
        timer.setEventHandler { [weak self] in
            os_log("centralManager:connect (peripheral=%s)", log: log, type: .debug, peripheral.description)
            self?.centralManagerConnectTimer[peripheral] = nil
            self?.centralManager.connect(peripheral)
        }
        timer.resume()
   }
    
    private func centralManager(connect identifier: UUID) {
        os_log("centralManager:connect (identifier=%s)", log: self.log, type: .debug, identifier.description)
        guard let peripheral = centralManager.retrievePeripherals(withIdentifiers: [identifier]).first else {
            os_log("centralManager:connect !peripheralNotFound (identifier=%s)", log: self.log, type: .fault, identifier.description)
            return
        }
        os_log("centralManager:connect -> connect (peripheral=%s)", log: self.log, type: .debug, peripheral.description)
        centralManager(connect: peripheral)
    }
    
    // MARK:- PeripheralManager extensions
    
    // MARK:- LocationManagerDelegate
    
    func locationManager(didDetect: LocationChange) {
        guard didDetect == .location else {
            return
        }
        os_log("locationManager:didDetect (change=%s)", log: self.log, type: .debug, didDetect.rawValue)
        //peripheralManagerStartAdvertising(peripheralManager, code: beaconCode)
        centralManagerScanForPeripherals(centralManager)
    }
    
    // MARK:- CBPeripheralManagerDelegate
    
    func peripheralManager(_ peripheral: CBPeripheralManager, willRestoreState dict: [String : Any]) {
        os_log("peripheralManager:willRestoreState", log: log, type: .debug)
        peripheralManager = peripheral
        peripheralManager.delegate = self
        if let services = dict[CBPeripheralManagerRestoredStateServicesKey] as? [CBMutableService] {
            for service in services {
                if let characteristics = service.characteristics {
                    for characteristic in characteristics {
                        if characteristic.uuid.values.upper == beaconCharacteristicCBUUID.values.upper, let characteristic = characteristic as? CBMutableCharacteristic {
                            let code = characteristic.uuid.values.lower
                            os_log("peripheralManager:willRestoreState:restoredCharacteristic (code=%s)", log: log, type: .debug, code.description)
                            peripheralManagerCharacteristic = characteristic
                        }
                    }
                }
            }
        }
    }

    func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) {
        os_log("peripheralManagerDidUpdateState (state=%s)", log: self.log, type: .debug, peripheral.state.description)
        peripheralManager = peripheral
        if peripheral.state == .poweredOn {
            os_log("peripheralManagerDidUpdateState:poweredOn -> startAdvertising", log: self.log, type: .debug)
            peripheralManager(peripheral, startAdvertising: beaconCode)
            return
        }
        delegates.forEach{$0.receiver(didUpdateState: peripheral.state)}
    }
    
    private func peripheralManager(_ peripheral: CBPeripheralManager, startAdvertising code: BeaconCode) {
        os_log("peripheralManager:startAdvertising -> addService (code=%s)", log: self.log, type: .debug, code.description)
        guard peripheral.state == .poweredOn else {
            return
        }
        let upper = beaconCharacteristicCBUUID.values.upper
        let beaconCharacteristicCBUUID = CBUUID(upper: upper, lower: beaconCode)
        let characteristic = CBMutableCharacteristic(type: beaconCharacteristicCBUUID, properties: [.write, .notify], value: nil, permissions: [.writeable])
        let service = CBMutableService(type: beaconServiceCBUUID, primary: true)
        service.characteristics = [characteristic]
        peripheral.removeAllServices()
        peripheral.stopAdvertising()
        peripheral.add(service)
        peripheralManagerCharacteristic = characteristic
    }

    func peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) {
        os_log("peripheralManager:didAdd -> startAdvertising (service=%s,error=%s)", log: log, type: .debug, service.description, error?.localizedDescription ?? "nil")
        peripheral.startAdvertising([CBAdvertisementDataServiceUUIDsKey : [service.uuid]])
    }
    
    func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) {
        os_log("peripheralManagerDidStartAdvertising (characteristic=%s,error=%s)", log: log, type: .debug, peripheralManagerCharacteristic?.uuid.description ?? "nil", error?.localizedDescription ?? "nil")
    }
    
    func peripheralManager(_ peripheral: CBPeripheralManager, central: CBCentral, didSubscribeTo characteristic: CBCharacteristic) {
        os_log("peripheralManager:didSubscribeTo -> updateSubscribers (central=%s)", log: log, type: .debug, central.description)
        //peripheralManager(peripheral, updateSubscribers: [central])
    }
    
    func peripheralManager(_ peripheral: CBPeripheralManager, central: CBCentral, didUnsubscribeFrom characteristic: CBCharacteristic) {
        os_log("peripheralManager:didUnsubscribeFrom (central=%s)", log: log, type: .debug, central.description)
    }
    
    func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveWrite requests: [CBATTRequest]) {
        let centrals = requests.map{$0.central}
        os_log("peripheralManager:didReceiveWrite -> updateSubscribers (centrals=%s)", log: log, type: .debug, centrals.description)
        //peripheralManager(peripheral, updateSubscribers: centrals)
    }

    private func peripheralManager(_ peripheral: CBPeripheralManager, updateSubscribers centrals: [CBCentral]?) {
        os_log("peripheralManager:updateSubscribers -> updateValue (centrals=%s)", log: self.log, type: .debug, centrals?.description ?? "[]")
        guard let characteristic = peripheralManagerCharacteristic else {
            os_log("peripheralManager:updateSubscribers !missingCharacteristic", log: log, type: .fault)
            return
        }
        os_log("peripheralManager:updateSubscribers:characteristicSubscribers (characteristic=%s,subscribers=%s)", log: self.log, type: .debug, characteristic.description, characteristic.subscribedCentrals?.map({$0.description}).description ?? "[]")
        if !peripheral.updateValue(emptyData, for: characteristic, onSubscribedCentrals: centrals) {
            os_log("peripheralManager:updateSubscribers !queueIsFull -> peripheralManagerIsReady:toUpdateSubscribers", log: self.log, type: .fault)
        }
    }
    
    func peripheralManagerIsReady(toUpdateSubscribers peripheral: CBPeripheralManager) {
        os_log("peripheralManagerIsReady:toUpdateSubscribers -> notifySubscribers", log: log, type: .debug)
        peripheralManager(peripheral, updateSubscribers: nil)
    }
        
    // MARK:- CBCentralManagerDelegate
    
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        os_log("centralManagerDidUpdateState (state=%s)", log: self.log, type: .debug, central.state.description)
        guard central.state == .poweredOn else {
            return
        }
        centralManager = central
        centralManager.registerForConnectionEvents(options: [CBConnectionEventMatchingOption.serviceUUIDs: [beaconServiceCBUUID]])
        centralManagerScanForPeripherals(central)
    }
    
    func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) {
        os_log("centralManager:willRestoreState", log: log, type: .debug)
        centralManager = central
        if let restoredPeripherals = dict[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] {
            for peripheral in restoredPeripherals {
                centralManager(register: peripheral)
                os_log("centralManager:willRestoreState:restored (peripheral=%s,state=%s)", log: log, type: .debug, peripheral.identifier.uuidString, peripheral.state.description)
            }
        }
    }
    
    func centralManagerScanForPeripherals(_ central: CBCentralManager) {
        os_log("centralManagerScanForPeripherals ====================", log: log, type: .debug)
        scheduleCentralManagerScanForPeripherals()
        central.retrieveConnectedPeripherals(withServices: [beaconServiceCBUUID]).forEach() { peripheral in
            os_log("centralManager:scanForPeripherals:retrieveConnectedPeripherals -> connect (uuid=%s,state=%s)", log: log, type: .debug, peripheral.identifier.uuidString, peripheral.state.description)
            centralManager(connect: peripheral)
        }
//        let identifiers = settings.peripherals().sorted{$0 < $1}.compactMap{UUID(uuidString: $0)}
//        central.retrievePeripherals(withIdentifiers: identifiers).forEach() { peripheral in
//            os_log("centralManager:scanForPeripherals:retrievePeripherals (uuid=%s,state=%s)", log: log, type: .debug, peripheral.identifier.uuidString, peripheral.state.description)
//        }
        os_log("centralManager:scanForPeripherals", log: log, type: .debug)
        central.scanForPeripherals(
            withServices: [beaconServiceCBUUID],
            options: [CBCentralManagerScanOptionSolicitedServiceUUIDsKey: [beaconServiceCBUUID]])
    }
    
    func centralManager(_ central: CBCentralManager, connectionEventDidOccur event: CBConnectionEvent, for peripheral: CBPeripheral) {
        os_log("centralManager:connectionEventDidOccur (event=%s,peripheral=%s)", log: log, type: .debug, event.description, peripheral.description)
//        switch event {
//        case .peerConnected:
//            centralManager(register: peripheral)
//            centralManager.connect(peripheral)
//        case .peerDisconnected:
//            dispatchQueue.asyncAfter(deadline: DispatchTime.now().advanced(by: .seconds(4))) {
//                os_log("centralManager:connectionEventDidOccur:dereferenced (peripheral=%s)", log: self.log, type: .debug, peripheral.description)
//                self.centralManager(deregister: peripheral)
//            }
//        @unknown default:
//            os_log("centralManager:connectionEventDidOccur:eventUnknown (event=%s,peripheral=%s)", log: log, type: .fault, event.description, peripheral.description)
//        }
    }


    func scheduleCentralManagerScanForPeripherals() {
        centralManagerScanTimer?.cancel()
        centralManagerScanTimer = DispatchSource.makeTimerSource(queue: timerQueue)
        centralManagerScanTimer?.schedule(deadline: DispatchTime.now().advanced(by: transceiverNotificationDelay))
        centralManagerScanTimer?.setEventHandler { [weak self] in
            guard let centralManager = self?.centralManager else {
                return
            }
            self?.centralManagerScanForPeripherals(centralManager)
        }
        centralManagerScanTimer?.resume()
    }

    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
        os_log("centralManager:didDiscover -> connect (peripheral=%s)", log: log, type: .debug, peripheral.description)
        centralManager(connect: peripheral)
    }

    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        os_log("centralManager:didConnect -> readRSSI (peripheral=%s)", log: log, type: .debug, peripheral.description)
        peripheral.readRSSI()
    }
    
    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
        os_log("centralManager:didDisconnectPeripheral -> connect (peripheral=%s)", log: log, type: .debug, peripheral.description)
        centralManager(connect: peripheral)
    }
    
    func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
        os_log("centralManager:didFailToConnect -> connect (peripheral=%s)", log: log, type: .debug, peripheral.description)
        centralManager(connect: peripheral)
    }
    
    // MARK:- CBPeripheralDelegate
    
    func peripheral(_ peripheral: CBPeripheral, didReadRSSI RSSI: NSNumber, error: Error?) {
        let uuid = peripheral.identifier.uuidString
        let rssi = RSSI.intValue
        // Unknown peripheral
        guard let beacon = centralManagerCachedBeaconData[uuid] else {
            os_log("peripheral:didReadRSSI:firstCall -> discoverServices (rssi=%s,peripheral=%s)", log: log, type: .debug, rssi.description, peripheral.description)
            let beacon = CachedBeaconData()
            beacon.rssi = rssi
            centralManagerCachedBeaconData[uuid] = beacon
            peripheral.discoverServices([beaconServiceCBUUID])
            return
        }
        // Known peripheral
        beacon.rssi = rssi
        guard let code = beacon.code, let os = beacon.operatingSystem else {
            os_log("peripheral:didReadRSSI:getCodeAndOs -> discoverServices (rssi=%s,,beacon=%s,peripheral=%s)", log: log, type: .debug, rssi.description, beacon.description, peripheral.description)
            peripheral.discoverServices([beaconServiceCBUUID])
            return
        }
        guard beacon.codeIsValid else {
            os_log("peripheral:didReadRSSI:refreshCode -> discoverServices (rssi=%s,beacon=%s,peripheral=%s)", log: log, type: .debug, rssi.description, beacon.description, peripheral.description)
            peripheral.discoverServices([beaconServiceCBUUID])
            return
        }
        // Notify delegates
        os_log("peripheral:didReadRSSI -> didDetect (beacon=%s,peripheral=%s)", log: log, type: .debug, beacon.description, peripheral.description)
        delegates.forEach{$0.receiver(didDetect: code, rssi: rssi)}
        // Android -> disconnect, iOS -> requestCallback
        guard let characteristic = beacon.characteristic else {
            os_log("peripheral:didReadRSSI:android -> cancelPeripheralConnection (peripheral=%s)", log: log, type: .debug, peripheral.description)
            centralManager.cancelPeripheralConnection(peripheral)
            return
        }
        os_log("peripheral:didReadRSSI:ios -> setNotifyValue (peripheral=%s)", log: log, type: .debug, peripheral.description)
        peripheral.setNotifyValue(true, for: characteristic)
    }
    
    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
        os_log("peripheral:didDiscoverServices (peripheral=%s)", log: log, type: .debug, peripheral.description)
        guard let service = peripheral.services?.filter({$0.uuid == beaconServiceCBUUID}).first else {
            os_log("peripheral:didDiscoverServices -> cancelPeripheralConnection (peripheral=%s)", log: log, type: .debug, peripheral.description)
            centralManager.cancelPeripheralConnection(peripheral)
            return
        }
        os_log("peripheral:didDiscoverServices -> discoverCharacteristics (peripheral=%s)", log: log, type: .debug, peripheral.description)
        peripheral.discoverCharacteristics(nil, for: service)
    }

    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        os_log("peripheral:didDiscoverCharacteristicsFor (peripheral=%s)", log: log, type: .debug, peripheral.description)
        guard let characteristic = service.characteristics?.filter({ $0.uuid.values.upper == beaconCharacteristicCBUUID.values.upper }).first else {
            os_log("peripheral:didDiscoverCharacteristicsFor -> cancelPeripheralConnection (peripheral=%s)", log: log, type: .debug, peripheral.description)
            centralManager.cancelPeripheralConnection(peripheral)
            return
        }
        // Cache discovered data
        let uuid = peripheral.identifier.uuidString
        if centralManagerCachedBeaconData[uuid] == nil {
            centralManagerCachedBeaconData[uuid] = CachedBeaconData()
        }
        let beacon = centralManagerCachedBeaconData[uuid]!
        beacon.code = BeaconCode(characteristic.uuid.values.lower)
        beacon.operatingSystem = (characteristic.properties.contains(.notify) ? .ios : .android)
        beacon.characteristic = characteristic
        if beacon.operatingSystem == .ios {
            os_log("peripheral:didDiscoverCharacteristicsFor:ios -> setNotifyValue (peripheral=%s)", log: log, type: .debug, peripheral.description)
            peripheral.setNotifyValue(true, for: characteristic)
        } else {
            os_log("peripheral:didDiscoverCharacteristicsFor:android -> cancelPeripheralConnection (peripheral=%s)", log: log, type: .debug, peripheral.description)
            centralManager.cancelPeripheralConnection(peripheral)
        }
        // Notify delegates
        guard let rssi = beacon.rssi, let code = beacon.code else {
            os_log("peripheral:didDiscoverCharacteristicsFor !missingRSSI (beacon=%s,peripheral=%s)", log: log, type: .fault, beacon.description, peripheral.description)
            return
        }
        os_log("peripheral:didDiscoverCharacteristicsFor -> didDetect (beacon=%s,peripheral=%s)", log: log, type: .debug, beacon.description, peripheral.description)
        delegates.forEach{$0.receiver(didDetect: code, rssi: rssi)}
    }
    
    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        os_log("peripheral:didUpdateValueFor (peripheral=%s)", log: log, type: .debug, peripheral.description)
        
    }

    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) {
        os_log("peripheral:didUpdateNotificationStateFor -> connect (peripheral=%s)", log: log, type: .debug, peripheral.description)
        centralManager(connect: peripheral)
    }
    
    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
        os_log("peripheral:didWriteValueFor (peripheral=%s)", log: log, type: .debug, peripheral.description)
    }
    
    func peripheral(_ peripheral: CBPeripheral, didModifyServices invalidatedServices: [CBService]) {
        os_log("peripheral:didModifyServices -> connect (peripheral=%s)", log: log, type: .debug, peripheral.description)
        centralManager(connect: peripheral)
    }
    
    private func peripheral(_ peripheral: CBPeripheral, requestCallback characteristic: CBCharacteristic) {
        os_log("peripheral:requestCallback -> writeValue (peripheral=%s,characteristic=%s)", log: self.log, type: .debug, peripheral.description, characteristic.description)
        peripheral.writeValue(emptyData, for: characteristic, type: .withResponse)
    }
}
